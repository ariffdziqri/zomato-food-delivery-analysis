---
title: "project_451"
output: html_document
date: "2025-11-30"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(tidymodels)
library(dplyr)
library(ggplot2)
library(shiny)
library(cluster)
library(geosphere)
```

## R Markdown

```{r, include=FALSE}
df = read_csv("../dataset/df.csv")
df$distance_miles = round(df$distance_miles, digits=3)
```



In this hw, my goal is to run a clustering algorithm on the Zomato Dataset to determine which hour is the peak hour of food ordered and time taken for food to be delivered. The main purpose of this task is to help customers optimize ordering food.

Background on the Dataset
Zomato is a food delivery company similar to Doordash and Foodpanda. This dataset was found in Kaggle and it represents real world dataset that was scraped from Zomato API.

```{r, include=FALSE}
cluster_df <- df %>%
  select(Road_traffic_density, distance_miles, City, Time_Orderd, `Time_taken (min)`) %>% 
  mutate(city_encode = case_when(
    City == "Semi-Urban" ~ 1,
    City == "Urban" ~ 2,
    TRUE ~ 3
  ),
  Road_traffic_density = case_when(
    Road_traffic_density == "High" ~ "Jam",
    TRUE ~ Road_traffic_density
  ),
  traffic_encode = case_when(
    Road_traffic_density == "Low" ~ 1,
    Road_traffic_density == "High" ~ 3,
    TRUE ~ 4
  ))

cluster_df$day_hour <- as.numeric(hour(cluster_df$Time_Orderd))
cluster_df$Road_traffic_density <- factor(cluster_df$Road_traffic_density, 
                        levels = c("Jam", "High", "Medium", "Low"))
cluster_df$City <- factor(cluster_df$City, levels = 
                            c("Metropolitian", "Urban", "Semi-Urban"))

```


Test
```{r, include=FALSE}
set.seed(133)
cluster2 <- cluster_f(cluster_df, 2)

cluster2 %>% 
  ggplot(aes(x= cluster2$day_hour, y=`Time_taken (min)`, 
             col=cluster2$Road_traffic_density,
             #size = factor(City, levels = c("Metropolitian", "Urban", "Semi-Urban")),
             group = .cluster)) +
  geom_point() +
  facet_wrap(~.cluster) +
  labs(
    color = "Traffic",
  )
```



```{r, include=FALSE}
# This is how I compute the Silhouette Score but I'll leave it as a comment because it takes very long to compute. I saved it in csv file for future use.

# K = c(2:10)
# 
# cluster_silhouette <- function(cluster_df, k){
#   x <- cluster_df %>%
#     select(-c (Time_Orderd, City, Road_traffic_density, ))
#   
#   kmeans(x, centers = k) %>% 
#     augment(cluster_df) %>% 
#     mutate(silhouette = silhouette(as.integer(.cluster), dist(x))[, "sil_width"])
# }
# 
# avg_score <- c()
# wcss_values <- c()
# 
# for (k in K) {
#   kclust <- cluster_silhouette(cluster_df, k)
#   avg_score <- c(avg_score, mean(kclust$silhouette))
# }
# 
# avg_score
# K_score <- tibble(
#   "K" = K,
#   "Silhouette" = avg_score
# )
# 
# 
# write_csv(K_score, "../dataset/K_Silhouette.csv")
```
Since Cluster 2 has athe highest silhouette, lets choose cluster 2



```{r}
#def for shiny
K_score <- read_csv("../dataset/K_Silhouette.csv")

options1 <- c("Road_traffic_density", "City")
options2 <- c("day_hour", "distance_miles")
color_palette <- c("red", "steelblue", "lightgreen")

cluster_f <- function(cluster_df, k){
  x <- cluster_df %>%
    select(-c (Time_Orderd, City, Road_traffic_density, ))
  
  kmeans(x, centers = k) %>% 
    augment(cluster_df)
}

final_df <- function(df, k){
  df <- cluster_f(df, k)
  df %>% 
    left_join(
      df %>% group_by(.cluster) %>% 
    summarise(avg_time = mean(`Time_taken (min)`))
    )
}


scatter <- function(df, x, color_type){
  df %>% 
    ggplot(aes(x= x, y=`Time_taken (min)`, 
               #size = factor(City, levels = c("Metropolitian", "Urban", "Semi-Urban")),
               group = .cluster)) +
    geom_point(aes(color = color_type)) +
    scale_color_manual(values = color_palette) +
    facet_wrap(~reorder(.cluster, avg_time)) +
    labs(
      color = "Traffic",
      x = str(x)
    )
}
```


```{r}

ui <- fluidPage(
   titlePanel("K-Means Clustering of Zomato Delivery Patterns"),
   h3("Interactive Visualization of How Traffic, Distance, type of city, and Time-of-Day Influence Delivery Time"),
   br(),
   div(
    style = "font-size: small; color: #555555;", # Custom CSS style
    p("Zomato is a major Indian app-based food delivery platform where delivery time is shaped by factors such as traffic congestion, distance traveled, and the time of day an order is placed. This Shiny app applies K-Means clustering to a subset of Zomato’s delivery data to uncover hidden structure in these patterns and identify which conditions most strongly influence delivery duration. The purpose of the visualization is to make the clustering process interpretable while also helping customers optimize when they order food by revealing peak-hour delays and the impact of traffic on delivery speeds.")
  ),
  br(),
  div(
    style = "font-size: small; color: #555555;", # Custom CSS style
    p("Users can adjust the number of clusters (K), switch between x-axis variables such as time-of-day or distance, and color deliveries by traffic level or city type to explore how different operational factors shape delivery behavior. Faceted scatterplots display each cluster separately, and the silhouette score provides immediate feedback on how well the clusters separate. Together, these interactive elements allow users to investigate meaningful behavioral patterns—such as lunch and dinner rush peaks, the dominant effect of congestion on delivery time, and the weaker influence of distance or city type—offering both model interpretability and actionable insight for smarter food-ordering decisions.")
  ),
   sliderInput("k", "Select number of K", 2, min=2, max=10),
   selectInput(inputId = "x", label = "x-axis", choices = options2),
   selectInput(inputId = "traffic_city", label = "Choose Color Variable", choices = options1),
   plotOutput(outputId = "scatter"),
   tableOutput(outputId = "kscore")
)
  server <- function(input, output){
    
    #filters from input
    df <- reactive({
      req(input$k)
      return(final_df(cluster_df, input$k))
    })
    
    x_axis <- reactive({
      req(input$x)
      if (input$x == "distance_miles"){
        x <- df()$distance_miles
      }else {x <- df()$day_hour}
      return(x)
    })
    
    k_table <- reactive({
      req(input$k)
      k_df <- K_score %>% 
        filter(K == input$k)
      return(k_df)
    })
    
    color_filter <- reactive({
      req(input$traffic_city)
      if (input$traffic_city == "Road_traffic_density"){
        color_type <- df()$Road_traffic_density
      }else {color_type <- df()$City}
        
      return(color_type)
    })
    
    
    #Outputs
    output$scatter <- renderPlot(
      scatter(df = df(), x = x_axis(), color_type =  color_filter())
    )
    
    output$kscore <- renderTable({
      k_table()
    })
    
}  
  
shinyApp(ui,server) 
```





